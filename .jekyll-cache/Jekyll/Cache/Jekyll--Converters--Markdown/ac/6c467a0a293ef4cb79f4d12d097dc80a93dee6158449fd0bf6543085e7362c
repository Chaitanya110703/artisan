I"Õ<p>Artisan supports the communication of JSON over WebSockets.</p>

<figure>
<a href="/assets/images/websockets-tab.png">
<img src="/assets/images/websockets-tab.png" /></a>
    <figcaption>WebSockets tab</figcaption>
</figure>

<h2 id="websocket-devices">WebSocket Devices</h2>

<p>There is one main WebSocket device type and 4 extra device, each delivering two channels, thus 10 channels of data in total.</p>

<p>The WebSocket connection as well as those 10 WebSocket channels are configured in the WebSocket dialog (menu Config¬†¬ª Port, 7th tab).</p>

<p>The WebSocket endpoint <code class="language-plaintext highlighter-rouge">ws://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code>  is configured via the <code class="language-plaintext highlighter-rouge">&lt;host&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;port&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;path&gt;</code> components.</p>

<p>Connect, reconnect and request timeouts are specified in seconds.</p>

<p>Data request messages have the following general form:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  &lt;Command&gt;: &lt;Data Request&gt;, 
  &lt;Message ID&gt;: nnnn, 
  &lt;Machine ID&gt;: &lt;ID&gt;
}
</code></pre></div></div>

<p>All node tags can be configured in the WebSocket tab.</p>

<p>The message id, the number <code class="language-plaintext highlighter-rouge">nnn</code>, is automatically generated. The corresponding response is expected to hold the same message id at its <Message ID=""> node. Multiple machines can be differentiated via the `<Machine ID="">` node with the value taken from the `ID` setting.</Machine></Message></p>

<p>If the <code class="language-plaintext highlighter-rouge">Data Request</code> field is non-empty, a corresponding request for data of the above form is send each sampling interval. This request is expected to be responded by a message holding data for all WebSocket inputs.</p>

<p>If the <code class="language-plaintext highlighter-rouge">Request</code> field of one WebSocket input channel is non-empty, a corresponding data request message with its field value taken as <code class="language-plaintext highlighter-rouge">&lt;Command&gt;</code> node value is send each sampling interval. This request is expected to be responded by a message holding data for just this WebSocket input.</p>

<p>Note that requesting the data for all WebSocket inputs in one <code class="language-plaintext highlighter-rouge">Data Request</code> is usually more efficient.</p>

<p>A data request message as described above is expected to be answered by a response message of the following form</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  &lt;Message ID&gt;: nnnn,
  &lt;Data&gt;: { &lt;node_0&gt; : v0, .., &lt;node_n&gt; : vn} 
}
</code></pre></div></div>

<p>with the message id <code class="language-plaintext highlighter-rouge">nnn</code> has to correspond to the one of the request message and the <code class="language-plaintext highlighter-rouge">&lt;node_0&gt;</code>,..,<code class="language-plaintext highlighter-rouge">&lt;node_n&gt;</code> nodes hold the data for the corresponding WebSocket input channels.</p>

<h2 id="websocket-push-messages">WebSocket Push Messages</h2>

<p>Artisan is listening to two push messages that are received without an explicit request.</p>

<ul>
  <li>CHARGE Message: <code class="language-plaintext highlighter-rouge">{ &lt;Message&gt;: &lt;CHARGE&gt; }</code></li>
  <li>DROP Message: <code class="language-plaintext highlighter-rouge">{ &lt;Message&gt;: &lt;DROP&gt; }</code></li>
</ul>

<p>On receiving the CHARGE message, the CHARGE event is set. On receiving the DROP message, the DROP event is set.</p>

<p>In case Artisan is not yet recording on receiving the CHARGE message and the <code class="language-plaintext highlighter-rouge">START on CHARGE</code> flag is ticked, the recording is automatically started before the CHARGE event is registered.</p>

<p>In case Artisan is recording on receiving the DROP message and the <code class="language-plaintext highlighter-rouge">OFF on DROP</code> flag is ticked, the recording is automatically stopped after the DROP event is registered.</p>

<h2 id="websocket-events">WebSocket Events</h2>

<p>Artisan is listening on Event Messages of the format</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  &lt;Message&gt;: &lt;Event&gt;,
  &lt;data&gt;: { &lt;Node&gt; : &lt;Tag&gt;} 
}
</code></pre></div></div>

<p>A message with  a <code class="language-plaintext highlighter-rouge">&lt;Tag&gt;</code> from the set <code class="language-plaintext highlighter-rouge">&lt;DRY&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;FCs&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;FCe&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;SCs&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;SCe&gt;</code> activates the corresponding event button in Artisan.</p>

<h2 id="websocket-commands">WebSocket Commands</h2>

<p>Buttons and sliders can send out <code class="language-plaintext highlighter-rouge">WebSocket Command</code>s. The following commands in the action description are supported.</p>

<p>Note that WebSocket Command actions can be sequenced by separating them with semicolons like in <code class="language-plaintext highlighter-rouge">sleep(2.5); send({{"command": "keepAlive"}})</code></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">send(&lt;json&gt;)</code>:<br />
if the <code class="language-plaintext highlighter-rouge">&lt;json&gt;</code> text respects the JSON format it is send to the connected WebSocket server</li>
  <li><code class="language-plaintext highlighter-rouge">sleep(s)</code> :<br />
delay processing by <code class="language-plaintext highlighter-rouge">s</code> seconds (float)</li>
  <li><code class="language-plaintext highlighter-rouge">read(&lt;json&gt;)</code>: 
if the <code class="language-plaintext highlighter-rouge">&lt;json&gt;</code> text respects the JSON format it is send to the connected WebSocket server and the response is bound to the variable <code class="language-plaintext highlighter-rouge">_</code></li>
  <li>`button(<expr>) :
sets the last button state to either "pressed" if <expr> evalutes to 1 or True and "normal", otherwise</expr></expr></li>
</ul>

<p>Example Button Action:</p>
<pre><code class="language-`">read({{"command": "getRoasterState"}});button(_["data"]["state"] == "ready")
</code></pre>
<p>Send <code class="language-plaintext highlighter-rouge">getRoasterState</code> request on button perss and sets the button in ‚Äúpressed‚Äù state if response indicate `ready‚Äô).</p>

<p>The placeholder <code class="language-plaintext highlighter-rouge">{}</code> is substituted by the event value in button and slider actions.  However, if the WebSocket Command is used as button or  slider actinon where this substition takes place all regular brackets have to be escaped by duplicating them like in the following example</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>send(
  {{ "command": "setControlParams", 
     "params": {{ "burner": {} }}
  }}
)
</code></pre></div></div>

<p>The placeholders <code class="language-plaintext highlighter-rouge">{BT}</code>, <code class="language-plaintext highlighter-rouge">{ET}</code>, <code class="language-plaintext highlighter-rouge">{time}</code> substituted in WebSocket Command actions by the current bean temperature (BT), environmental temperature (ET) or the time in seconds (float). Again, if such a placeholder is used in a WebSocket Command, all JSON elements have to be wrapped in an extra set of brackets like in the following example.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
send({{"command": "keepAlive", "params": {BT}}})

</code></pre></div></div>
:ET